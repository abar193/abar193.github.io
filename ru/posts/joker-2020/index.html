<!DOCTYPE html>
<html lang="en">

  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">

    <meta name="author" content="Антон Б.">
    <meta name="description" content="Simplifying stuff for business needs">
    <meta name="keywords" content="blog,developer,personal">

    <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Joker 2020."/>
<meta name="twitter:description" content="Пост на Хабр."/>

    <meta property="og:title" content="Joker 2020." />
<meta property="og:description" content="Пост на Хабр." />
<meta property="og:type" content="article" />
<meta property="og:url" content="https://mrabar.me/ru/posts/joker-2020/" /><meta property="article:section" content="posts" />
<meta property="article:published_time" content="2020-12-21T16:41:04&#43;02:00" />
<meta property="article:modified_time" content="2020-12-21T16:41:04&#43;02:00" /><meta property="og:site_name" content="Mr. Abar (ru)" />



    
      <base href="https://mrabar.me/ru/posts/joker-2020/">
    
    <title>
  Joker 2020. · Mr. Abar (ru)
</title>

    
      <link rel="canonical" href="https://mrabar.me/ru/posts/joker-2020/">
    

    <link href="https://fonts.googleapis.com/css?family=Lato:400,700%7CMerriweather:300,700%7CSource+Code+Pro:400,700" rel="stylesheet">
    <link rel="stylesheet" href="https://use.fontawesome.com/releases/v5.3.1/css/all.css" integrity="sha384-mzrmE5qonljUremFsqc01SB46JvROS7bZs3IO2EmfFsd15uHvIt+Y8vEf7N7fWAU" crossorigin="anonymous" />
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/normalize/8.0.0/normalize.min.css" integrity="sha256-oSrCnRYXvHG31SBifqP2PM1uje7SJUyX0nTwO2RJV54=" crossorigin="anonymous" />

    
      
      
      <link rel="stylesheet" href="https://mrabar.me/css/coder.min.28d751104f30c16da1aa1bb04015cbe662cacfe0d1b01af4f2240ad58580069c.css" integrity="sha256-KNdREE8wwW2hqhuwQBXL5mLKz&#43;DRsBr08iQK1YWABpw=" crossorigin="anonymous" media="screen" />
    

    

    

    
      <link rel="stylesheet" href="https://mrabar.me/css/custom.css">
    

    <link rel="icon" type="image/png" href="https://mrabar.me/img/favicon.ico" sizes="32x32">
    <link rel="icon" type="image/png" href="https://mrabar.me/img/favicon.ico" sizes="16x16">

    <meta name="generator" content="Hugo 0.83.1" />
  </head>

  <body class=" ">
    <main class="wrapper">
      <nav class="navigation">
  <section class="container">
    <a class="navigation-title" href="https://mrabar.me/">
      Mr. Abar (ru)
    </a>
    <input type="checkbox" id="menu-toggle" />
    <label class="menu-button float-right" for="menu-toggle"><i class="fas fa-bars"></i></label>
    <ul class="navigation-list">
      
        
          <li class="navigation-item">
            <a class="navigation-link" href="https://mrabar.me/ru/posts/">Блог</a>
          </li>
        
      
      
        
        
        
          
            
              <li class="navigation-item menu-separator">
                <span>|</span>
              </li>
              
            
            <li class="navigation-item">
              <a href="https://mrabar.me/">ENG</a>
            </li>
          
        
          
        
      
    </ul>
  </section>
</nav>


      <div class="content">
        

  <section class="container post">
    <article>
      <header>
        <div class="post-title">
          <h1 class="title">Joker 2020.</h1>
          <h4 style="margin: 1rem 0;">Пост на Хабр.</h4>
        </div>
        <div class="post-meta">
          <div class="date">
            <span class="posted-on">
              <i class="fas fa-calendar"></i>
              <time datetime='2020-12-21T16:41:04&#43;02:00'>
                21.12.2020
              </time>
            </span>
            <span class="reading-time">
              <i class="fas fa-clock"></i>
              16 * 60 секунд на чтение
            </span>
          </div>
          <div class="categories">
  <i class="fas fa-folder"></i>
    <a href="https://mrabar.me/ru/categories/conferences/">conferences</a></div>

          <div class="tags">
  <i class="fas fa-tag"></i>
    <a href="https://mrabar.me/ru/tags/java/">java</a>
      <span class="separator">•</span>
    <a href="https://mrabar.me/ru/tags/spring/">spring</a>
      <span class="separator">•</span>
    <a href="https://mrabar.me/ru/tags/microservices/">microservices</a></div>


          

        </div>
      </header>
      <aside>
        <h1 class="title">Оглавление</h1>
        <nav id="TableOfContents">
  <ul>
    <li><a href="#spring-your-next-java-microframework">Spring: Your next Java microframework</a>
      <ul>
        <li><a href="#лёгкость-разработки">Лёгкость разработки</a></li>
        <li><a href="#скорость-запуска">Скорость запуска</a></li>
        <li><a href="#простота-понятность-в-разработке">Простота (понятность) в разработке</a></li>
        <li><a href="#cloud-ready">Cloud-ready</a></li>
      </ul>
    </li>
    <li><a href="#how-we-did-sql-in-hazelcast">How we did SQL in Hazelcast</a></li>
    <li><a href="#spring-boot-fat-jar-thin-parts-of-a-thick-artifact">Spring Boot “fat” JAR: Thin parts of a thick artifact</a></li>
    <li><a href="#hidden-pearls-for-high-performance-persistence-in-java">Hidden pearls for high-performance-persistence in Java</a></li>
    <li><a href="#spring-patterns-for-adults">Spring Patterns for adults</a></li>
    <li><a href="#и-ещё">И ещё&hellip;</a>
      <ul>
        <li><a href="#java-licensing-tips">Java Licensing Tips</a></li>
        <li><a href="#how-to-tell-no-to-an-architect-tips-for-sizing-a-microservice">How to tell &ldquo;no&rdquo; to an architect? Tips for sizing a microservice</a></li>
        <li><a href="#will-robots-replace-programmers">Will robots replace programmers?</a></li>
      </ul>
    </li>
    <li><a href="#заключение">Заключение</a></li>
  </ul>
</nav>
      </aside>
      <div>
        <blockquote>
<p>Это - перевод моих англоязычных заметок с этого же сайта, который я выложил на <a href="https://habr.com/ru/post/531666/">Хабр</a>. Мой первый пост туда зашел нормально, я получил пару замечаний, даже от оригинального автора одного из докладов, откорректировал пост с учётом замечаний. Это - копия финальной версии, на случай если Хабр упадёт, а мой блог - нет.</p>
</blockquote>
<p>Вот и прошла конференция Joker 2020 для Java senior-ов. Для меня эта конференция стала особенной сразу по нескольким причинам - это первая &ldquo;серьёзная&rdquo; техническая конференция на которую я попал (в качестве зрителя), это моя первая онлайн-конференция, и это первая конференция, билет на которую я купил сам, а не за счёт работодателя.</p>
<p><img src="https://habrastorage.org/webt/hb/yu/lx/hbyulxzbzsnzt77k3f29lu4piwo.png" alt="">
<em>Изображение <a href="https://jokerconf.com/en/">отсюда</a></em></p>
<p>Потраченные деньги, плюс возможность пересматривать любую трансляцию мотивировали меня просмотреть как можно больше материала, в результате даже через неделю после завершения конференции, я всё ещё продолжал сидеть и конспектировать выступление за выступлением. <em>Совершенно нормальное поведение, хватит всем на меня так пялиться. Нет, я не пойду с добрым дядей доктором на обследование, спасибо.</em></p>
<p>Сразу предупреждаю, что даже так я не сумел просмотреть все трансляции, но если кому-то интересно, что же из этого получилось - добро пожаловать под кат. <!-- raw HTML omitted --></p>
<h1 id="spring-your-next-java-microframework">Spring: Your next Java microframework</h1>
<p>Презентация от <a href="https://twitter.com/alek_sys">Алексея Нестерова</a>, в которой он доказывает, что Spring Boot может выглядеть как микрофреймворк, вести себя как микрофреймворк и даже крякать как микрофреймвок, а если так - то что же нам ещё нужно?</p>
<p>От микрофрейморках люди, как правило, ожидают несколько качеств: простоты разработки, &ldquo;понятности&rdquo; работы (simple vs easy), скорости работы, и готовности к работе в &ldquo;облаке&rdquo; (cloud-readiness, cloud-native). Как ни странно, Спринг может соответствовать всем этим критериям, и Алексей готов это доказать.</p>
<h2 id="лёгкость-разработки">Лёгкость разработки</h2>
<p>У Spring есть <a href="https://docs.spring.io/spring-boot/docs/2.4.x-SNAPSHOT/reference/html/using-spring-boot.html#using-boot-devtools">Boot Devtools</a>, позволяющий, помимо всего прочего:</p>
<ul>
<li>получить LiveReload в браузере</li>
<li>отключить кэширование шаблонов</li>
<li>перезагружать сервис при обновлении файлов в classpath как локально, так и удалённо (но только не делайте так на продакшене, пожалуйста)</li>
</ul>
<h2 id="скорость-запуска">Скорость запуска</h2>
<p>Спринг может быть быстр для запуска, но надо понимать что вообще делает ваш код. Если вы грузите сторонние сервисы, или лезете в БД при запуске - нечего пенять на Спринг! Помимо этого оптимизировать старт могут следующие советы:</p>
<ul>
<li>распакуйте executable JAR и укажите Main класс</li>
<li>используйте spring-context-indexer</li>
<li>используйте функциональные бины</li>
<li>уберите Actuator</li>
<li>используйте реактивный стек</li>
</ul>
<p>Боттлнеком всегда может стать ваш CPU, может быть проблема ещё в JVM - попробуйте разные, например J9, попробуйте CDS, или скомпилируйте в нативный файл с GraalVM.</p>
<p>Если совсем ничего не остаётся <em>(или если вам платят только за оптимизацию времени старта)</em> - переделайте все бины на ленивые, и используйте ленивую загрузку для репозиториев. <em>И пусть кто-то другой разбирается с проблемой тормозящего первого запроса.</em></p>
<p>Примечания в <em>курсиве</em> - от меня, это не слова докладчика.</p>
<h2 id="простота-понятность-в-разработке">Простота (понятность) в разработке</h2>
<p>Тут докладчик потратил время на объяснение о том, чем в его представлении &ldquo;easy&rdquo; отличается от &ldquo;simple&rdquo;. Очень надеюсь, что я понял правильно, что &ldquo;easy&rdquo; - это та &ldquo;магия&rdquo; Спринга, при которой ты просто вешаешь пачку аннотаций по коду и всё начинает работать &ldquo;само собой&rdquo; - на механизмах, зашитых в сам Спринг. В противовес этому есть &ldquo;simple&rdquo; - когда вы явно прописываете что идёт за чем, имеете полный контроль над кодом, но добавление новых компонент будет сопровождаться дополнительной работой с вашей стороны. Здесь не будет идеального решения, каждому разработчику/команде надо решать для себя, что им конкретно сейчас важнее.</p>
<p>Для обеспечения &ldquo;понятности&rdquo; разработки, в новых версиях Спринга появились такие альтернативы уже существующим механизмам:</p>
<ul>
<li><strong>Functional beans</strong> вместо Component Scanning</li>
<li><strong>Functional routing</strong> вместо Route mapping</li>
<li>Использование <code>@Query</code> или миграция с JPA вместо использования Generated Queries</li>
<li>Manual import вместо Autoconfigurations</li>
</ul>
<p>Оказывается, пока я учился мигрировать конфигурацию сервисов с XML на аннотации спринга, умные люди сделали ещё и <a href="https://cloud.spring.io/spring-cloud-function/multi/multi__functional_bean_definitions.html">Functional beans</a> с <a href="https://spring.io/blog/2016/09/22/new-in-spring-5-functional-web-framework">Functional routing</a> на лямбдах. Все три метода поддерживаются и могут работать дополняя друг друга, но новая функциональная конфигурация должна быть чуть-чуть быстрее, потому что не использует рефлексию.</p>
<p>С помощью новых механизмов, весь (микро-)сервис можно описать исключительно из Main-а, не используя никаких других методов конфигурации.</p>
<p>Все четыре тезиса были подкреплены демонстрацией примеров, в этом случае - на использование <code>applicationContext.registerBean(...)</code> и <code>RouterFunction</code>, <code>route().GET(&quot;/foo&quot;, request -&gt; { ... })</code>.</p>
<h2 id="cloud-ready">Cloud-ready</h2>
<p>Напоследок, cloud-ready, но тут даже и обсуждать нечего - это движение по сути, со спринга и началось, Spring Cloud содержит готовые механизмы для Circuit Breakers, конфигурации, Service registry, балансировка нагрузки, API gateways, даже Serverless с Spring Cloud Function.</p>
<p>Сприг поддерживает такие платформы как Kubernetes, Cloud Foundry, AWS, Alibaba и другие.</p>
<p>Докладчик так же посоветовал посмотреть на Java Memory Calculator проект для тех, кто редактирует Dockerfile руками.</p>
<p>Из диалога с экспертами и ответов на вопросы стало понятно, что Spring DevTools перезагружают весь сервис - если у вас какие-то свои сессии на Spring Security - они будут пропадать. Функциональные бины работают так же, как и обычные. Пост процессоры бинов могут быть зарегистрированы точно так же.</p>
<h1 id="how-we-did-sql-in-hazelcast">How we did SQL in Hazelcast</h1>
<p>Презентация от <a href="https://twitter.com/devozerov">Владимира Озерова</a>, в которой он показал основные принципы проектирования своего распределенного SQL хранилища, основываясь на опыте своей компании.</p>
<p>Изначально у них было предикатное API для хранения in-memory индексов, но этого было не достаточно, так как не давало нужной гибкости. В первых версиях они перешли на простые запросы вида <code>select ... from ... where</code> с использованием индексов. Оптимизация SQL запросов - это очень сложные задачи, к счастью в мире есть несколько решений, и одно из которых они решили использовать - это <a href="https://calcite.apache.org/">Apache Calcite</a>.</p>
<p>Процесс оптимизации запроса &ldquo;по верхам&rdquo; состоит из трёх шагов: анализ синтаксиса, анализ семантики, и оптимизация. По теме оптимизации есть множество исследовательских работ, например, “Access Path Selection in a Relational Database Management System”, “The Cascades Framework for Query Optimization”.</p>
<p><em>Ремарка от меня</em>. До сих пор мне приходилось работать с SQL, например, с такими задачами как поддержка вызовов хранимых процедур на легаси системах, или использование больших и сложных SQL запросов, предоставленных нам от DBA. Так что название презентации меня очень заинтересовало, и я с интересом был готов послушать что-то новое. Однако, в этот момент даже до меня дошло, что что-то здесь не так, и тема как-то не похожа на ту, что я ожидал услышать, так что я решил &ldquo;откланяться&rdquo; и пойти слушать другой доклад. Тем не менее тема должна быть интересна, и кто хочет - может досмотреть её самостоятельно.</p>
<h1 id="spring-boot-fat-jar-thin-parts-of-a-thick-artifact">Spring Boot “fat” JAR: Thin parts of a thick artifact</h1>
<p>Здесь докладчик по имени <a href="https://twitter.com/toparvion">Владимир Плизга</a>, вместе с экспертами <a href="https://twitter.com/belyaev_andrey">Андреем Беляевым</a> и <a href="https://twitter.com/andrei_kogun">Андреем Когуном</a> разобрал устройство &ldquo;fat&rdquo; JAR-а.</p>
<p>Вообще, технология &ldquo;fat&rdquo; JAR - не нова, и <a href="https://en.wikipedia.org/wiki/Matryoshka_doll">первые образцы технологии</a> были представлены ещё в 1890 году Василием Звёздочкиным. В спринге же существует с первой версии.</p>
<p>При запуске такого архива происходит следующая цепочка вызовов:
<img src="https://habrastorage.org/webt/fj/8q/8v/fj8q8v2bibd5em17cqzvdoor6ow.png" alt=""></p>
<p>Внешний архив размечается так:
<img src="https://habrastorage.org/webt/zi/dk/pf/zidkpfho3mqvtj4kguu4chwmt2s.png" alt=""></p>
<p>А вот так классы грузятся из архива:
<img src="https://habrastorage.org/webt/g7/ph/4m/g7ph4mco2dx0mttbhs8u1q5ghks.png" alt=""></p>
<p><em>Все слайды - из презентации Владимира, он поделился ими по следующей <a href="https://toparvion.pro/talk/2020/joker/">ссылке</a></em></p>
<p>Несколько замечаний докладчика: внутренние архивы <strong>не</strong> сжаты;
Spring вешает собственный наследник URLClassLoader-а на главный поток;
По сути чтение классов работает как чтение из внешнего архива с правильным отступом с использованием <code>RandomAccessFile</code>.</p>
<p>Если что-то пошло не так, то загрузку &ldquo;fat&rdquo; JAR-а можно отдебажить следующей последовательностью действий:</p>
<ol>
<li>Скачать нужную версию Spring Boot-а</li>
<li>Поставить брейкпойнт на <code>org.springframework.boot.loader.JarLauncher#main</code></li>
<li>Запустить джарку с параметром <code>-agentlib:jdwp=transport=dt_socket,server=y,suspend=y,address=*:5005</code></li>
<li>Подключиться дебагером из проекта</li>
</ol>
<p>Тут завязалась дискуссия с экспертами, из которой прояснили ещё несколько моментов:</p>
<ul>
<li>Загрузка может поломаться: например - может появиться Class/MethodNotFoundException если порядок JAR-ок в &ldquo;fat&rdquo; JAR-е различается</li>
<li>Запуск проекта из Идеи отличается от запуска самой джарки
<strong>Мораль - тестируйте fat JAR ещё на этапе разработки, что бы избежать проблем на продакшене</strong></li>
</ul>
<p>Использование &ldquo;fat&rdquo; JAR-а может потенциально поломать такие утилиты как <code>jshell</code>, <code>jdeps</code>, <code>jmint</code>, а так же пакет <code>java.util.logging</code> со всеми наследниками. Что бы это починить, постарайтесь не использовать ClassLoader.getSystemClassLoader(), или просто распаковывайте &ldquo;fat&rdquo; JAR перед использованием. Однако, даже со всеми этими недостатками fat &ldquo;JAR&rdquo; может помочь в миграции с application server&rsquo;а на Спринг бут.</p>
<p><strong>Поддержка докера</strong> с версии Spring Boot 2.3 (опционально - и с 2.4 - по умолчанию) в fat JAR добавился новый режим <code>-Djarmode=layertools</code>, позволяющий собирать артефакт <a href="https://spring.io/blog/2020/08/14/creating-efficient-docker-images-with-spring-boot-2-3">по слоям</a>, и это работает как с Maven, так и с Gradle плагинами. Посмотреть слои можно командой</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">java -Djarmode=layertools -jar fat.jar list
</code></pre></div><p>По умолчанию идут в таком порядке: зависимости, загрузчик спринг бута, snapshot зависимости, сгенерированный код, код приложения. Что именно попадёт в какой слой - можно <a href="https://docs.spring.io/spring-boot/docs/current/gradle-plugin/reference/htmlsingle/#packaging-layered-jars">менять и настраивать</a>. Далее, распакованный по слоям артефакт можно упаковать в докер вручную, с помощью докерфайла как-то так:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-fallback" data-lang="fallback">FROM .../openjdk-alpine:11 as builder
WORKDIR application
COPY fat.jar fat.jar
RUN java -Djarmode=layertools -jar fat.jar extract
...
FROM ...openjdk-alpine:11
WORKDIR application
COPY --from=builder application/dependencies/ ./
COPY --from=builder application/spring-boot-loader/ ./
...

ENTRYPOINT [&#34;java&#34;, &#34;org.springframework.boot.loader.JarLauncher&#34;]
</code></pre></div><p>Использование спрнгового JarLauncher&rsquo;а даже на распакованном артефакте позволяет нам сохранить &ldquo;магию&rdquo; Спринга, и, например, читать версию артефакта из манифеста.</p>
<p>Из презентации я так же узнал об утилите &ldquo;dive&rdquo;, которую докладчик использовал для просмотра слоёв в контейнере.</p>
<p>Разобравшись с ручной упаковкой докерфайла у экспертов возник закономерный вопрос: &ldquo;А где тут кнопка &lt;сделать хорошо&gt;&rdquo;?</p>
<p>Оказывается, есть и такое - разные инструменты, вроде <a href="https://docs.spring.io/spring-boot/docs/current/gradle-plugin/reference/htmlsingle/#build-image">Buildpacs</a>, или <a href="https://cloud.google.com/java/getting-started/jib">Google Jib</a>.</p>
<p>Разница между ними такая - если нужен полный контроль, то используйте Layertools, если нужна &ldquo;магия&rdquo; и размеры полученного артефакта не заботят - то Buildpacs, если нет возможности использовать докер, или невозможно обновить Спринг Бут до версии 2.3 - берите Jib.</p>
<p>Общие рекомендации с презентации:</p>
<ul>
<li>Проверяйте что идёт в class-path в IDE</li>
<li>Обновляйте Spring Boot до последней версии</li>
<li>Распаковывайте fat JAR в целевом окружении</li>
<li>Запускайте проект через JarLauncher, не Main-Class манифеста</li>
<li>Подумайте об удобстве использования с Buildpacs</li>
</ul>
<p>Дополнительные ссылки:</p>
<ul>
<li><a href="https://youtu.be/WL7U-yGfUXA">https://youtu.be/WL7U-yGfUXA</a></li>
<li><a href="https://reflectoring.io/spring-boot-docker/">https://reflectoring.io/spring-boot-docker/</a></li>
<li><a href="https://www.profit4cloud.nl/blog/building-containers-with-spring-boot-2-3/">https://www.profit4cloud.nl/blog/building-containers-with-spring-boot-2-3/</a></li>
</ul>
<h1 id="hidden-pearls-for-high-performance-persistence-in-java">Hidden pearls for high-performance-persistence in Java</h1>
<p>Презентация от <a href="https://twitter.com/SvenRuppert">Свена Рупперта</a>. Свен по максимуму воспользовался форматом онлайн презентации, и записал свою речь во время неторопливой прогулки по осеннему лесу с чашкой кофе. Несмотря на умиротворяющую атмосферу, сама презентация прошла в очень бодром темпе, а Свен успел перечислить и рассказать особенности множества интересных библиотек из мира Джавы.</p>
<p><a href="https://www.jooq.org/"><strong>JOOQ</strong></a>: кодогенератор для вызовов БД. <em>Вот только я подумал, что у меня наконец-то появилась идея своего проекта, которой ещё ни у кого не было&hellip;</em></p>
<p><img src="https://habrastorage.org/webt/z_/9g/vf/z_9gvf9xkznuj5bhoet-q77yr6g.png" alt=""></p>
<p>Позволяет генерировать DSL в зависимости от БД, со всеми таблицами и колонками, и использовать дальше в своих проектах. В бесплатной версии не поддерживает Oracle, SQL Server и MS Access.</p>
<p><a href="https://speedment.github.io/speedment-doc/overview.html"><strong>Speedment</strong></a>. <em>Хотел дать ссылку на их сайт, но там ошибка 500 - по злой иронии не может подключиться к БД и так лежит уже неделю</em></p>
<p>Позволяет генерировать DSL под БД, но на потоках Java 8. Все фильтры и выборки задаются в лямбдах, выглядит интересно. Сюда же можно отнести и <a href="https://jpastreamer.org/">JPA Streamer</a> - библиотеку, которая добавляет Java 8 streams поверх Hibernate.</p>
<p><a href="https://github.com/OpenHFT/Chronicle-Bytes"><strong>Chronicle Bytes</strong></a>: даёт два класса Bytes - для создания массивов байтов и MappedBytes - для привязки буфера к файлу. Написал в стиле С/С++ - записывать можешь что угодно в каком порядке, доставать обратно - тоже. Описания полей/классов не сохраняются, если при чтении перепутаешь порядок или попытаешься прочитать лишнее - сам виноват.</p>
<p><a href="https://github.com/OpenHFT/Chronicle-Map"><strong>Chronicle Map</strong></a> - быстрое key-value хранилище разработанное для высоко нагруженных многопоточных приложений, не ограничено размерами RAM-а, и может сохранять данные на диск.</p>
<p><a href="https://github.com/JetBrains/xodus"><strong>XODUS</strong></a> транзакционная schema-less встроенная БД, разработанная в JetBrains. Все изменения пишутся в иммутабельный лог.</p>
<p><a href="http://www.mapdb.org/"><strong>MapDB</strong></a> совмещает движок БД и коллекции Java. Позволяет использовать словари, списки, для хранения данных либо вне сборщика мусора, либо на диске.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">DB db = DBMaker.fileDB(<span style="font-style:italic">&#34;/some/file&#34;</span>).encryptionEnable(<span style="font-style:italic">&#34;password&#34;</span>).make();
ConcurrentNavigatableMap&lt;Integer, String&gt; map = db.treeMap(...); 
</code></pre></div><p>Можно использовать для получения многоуровневого кеша с истечением срока хранения, для хранения не влезающих в RAM данных диске, для последовательных бекапов, для фильтрации и обработки данных. Всё это достигается за счёт того, что типы хранилищ можно совмещать: например завести словарь вне GC, пишущий часть данных на диск.</p>
<p><a href="https://microstream.one/"><strong>Microstream</strong></a> - проект, реализовавший собственную сериализацию для объектов, и хорошо умеющий работать с графами. В бесплатной версии не работает с Oracle БД, и не даёт параллельное чтение/запись. Стартовый класс - EmbeddedStorageManager, в нём можно задать корень графа, сохранить на диск. Позволяет хранить модели как есть, или в виде коллекций. Позволяет работать только с частями графов, но даже зацикленные графы для них не проблема. Могут быть проблемы с наследованиями.</p>
<p>Помимо этого Mictorstream устраивают <a href="https://hackathon.microstream.one/">хакатон</a> с призовым фондом в 20к$, на котором Свен будет одним из членов жюри. До февраля есть возможность придумать какое-то интересное использование для этой библиотеки, выложить под лицензией Apache 2 и попробовать получить 5к$ на первом месте (всем участникам гарантируют майку).</p>
<h1 id="spring-patterns-for-adults">Spring Patterns for adults</h1>
<p>Последний крупный доклад, о котором я хотел бы здесь написать - это работа <a href="https://twitter.com/jekaborisov">Евгения Борисова</a>, которую он презентовал с приглашенными экспертами <a href="https://twitter.com/andrei_kogun">Андреем</a> и <a href="https://twitter.com/tolkv">Кириллом</a>. Говорили много и интересно - по докладу видно, что Евгений отлично разбирается в теме и очень живо делится своими знаниями, я попробую передать лишь основное.</p>
<p>При запуске <code>@ComponentScan</code>, Спринг начинает сканировать все компоненты, включая унаследованные <code>@Service/@Repository/@Controller/@RestController</code> и даже <code>@Configuration</code> - это тоже компонента. Работает это потому, что Спринг не ищет конкретные аннотации, а проверяет каждую найденную и перебирает всех её предков. Таким образом можно писать собственные аннотации (как <code>@MyCompanyController</code>), наследующие, или аннотированные аннотациями Спринга, и они будут работать точно так же с остальными контроллерами.</p>
<p>Довольно распространённая ошибка - кто-то пишет <code>@Lazy</code> компонент (<code>@Lazy Component</code>, <code>@Lazy @Service</code>, &hellip;) и не понимает, почему этот компонент стартует вместе со всеми, даже когда им никто не пользуется. Проблема в том, что любой <code>@Autowire</code> для компоненты - автоматически означает, что компонента нужна, и заставляет Спринг её создать. Решение простое - с версии 4.3 можно сделать <code>@Autowire @Lazy</code> - и вместо компоненты будет прокси-объект, который создаст реальную компоненту лишь тогда, когда кто-то начнёт ею пользоваться.</p>
<p>При тестировании приложений всегда есть проблема контекста, который надо разворачивать для тестирования. Разворачивать всё и всегда - долго, разворачивать только часть контекста в зависимости от теста - всегда есть риск, что что-то где-то будет падать из-за какой-то части проекта, в результате всё будет скатываться в первую ситуацию - когда для каждого теста разворачивается весь контекст. Для решения этой проблемы на тестах можно использовать <code>@ComponentScan(lazyInit = true)</code> (либо <code>spring.main.lazy-initialization=true</code> в файле настроек).</p>
<p>Была интересная дискуссия о том, так ли полезна инъекция параметров конструктора, которая, в отличие от инъекция по полям не должна - в теории - позволить растянуться коду в классе и должна помочь избежать создания &ldquo;божественных объектов&rdquo;, которые делают слишком много всего сразу. На практике же программист просто лепит <a href="https://projectlombok.org/features/constructor">@RequiredArgsConstructor</a> и классы продолжают расползаться.</p>
<p>Была ещё более интересная дискуссия о том, как использовать квалификаторы. К сожалению, текстом и в виде конспекта её не пересказать, я могу лишь показать картинку &ldquo;Айтишники на троих разбирают запутанный случай Spring Boot&rsquo;а&rdquo;.</p>
<p><img src="https://habrastorage.org/webt/o2/fv/tp/o2fvtpp9kfzqui107dvbozvrenu.png" alt=""></p>
<p>Далее, по паттернам. Для использования паттерна Chain of Responsibility в спринге можно инжектить списки. <code>@Autowired List&lt;Handler&gt; handlers;</code>заинжектит все компоненты, имплементирующие интерфейс <code>Hangler</code> - таким образом не надо будет их биндить по одному. Порядок будет произвольный, если нужен порядок, или какой-то особый список - то надо будет использовать BeanPostProcessor и собирать список самостоятельно из ApplicationContext.</p>
<p>Можно использовать Intrpspector.decapitalize() для получения имени бинов из имени класса.</p>
<p>Интересный пример того, как можно взять какой-либо старый фреймворк (например, из либы, которую нам нельзя менять) и заставить работать все старые легаси-компоненты в спринге. Делается это так с использованием <a href="https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/context/annotation/ImportBeanDefinitionRegistrar.html">ImportBeanDefinitionRegistrar</a></p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="font-weight:bold">class</span> <span style="font-weight:bold">LegacyBeanDefinitionRegistrar</span> <span style="font-weight:bold">implements</span> ImportBeanDefinitionRegistrar {
<span style="font-style:italic">// ...
</span><span style="font-style:italic"></span>registerBeanDefinition() {
      Reflections scanner = <span style="font-weight:bold">new</span> Reflections(<span style="font-style:italic">&#34;com.legacy.package&#34;</span>);
      Set&lt;Class&lt;?&gt;&gt; classes = scanner.getTypesAnnotatedWith(LegacySingleton.class);
      <span style="font-weight:bold">for</span>(Class&lt;?&gt; aClass : classes) {
        GenericBeanDefinition bd = <span style="font-weight:bold">new</span> GenericBeanDefinition();
        bd.setBeanClass(aClass);
        <span style="font-style:italic">// bd.addQualifier(new AutowireCandidateQualifier(Legacy.class)); // можно добавлять свои квалифаеры
</span><span style="font-style:italic"></span>        beanDefinition.setScope(beanDefinition.SCOPE_SINGLETON); <span style="font-style:italic">// например
</span><span style="font-style:italic"></span>
        registry.registerBeanDefinition(Introspector.decapitalize(aClass.getSimpleName()), bd);
      }
}
}
</code></pre></div><p>Начать использовать этот регистрар можно в классе с аннотацией <code>@Configuration @Import(LegacyBeanDefinitionRegistrar.class)</code>.</p>
<p>Далее, разобрали несколько вариантов того, как работать с паттерном Strategy &amp; Command. Например, если мы хотим, что бы от клиента приходил запрос о том, как именно обрабатывать его запрос. Тут возникает соблазн начать использовать switch, но это опасный путь - сперва у тебя 5 кейсов, потом 6, там и 7-ой добавить вроде не страшно, потом вдруг 10 - но рефакторить уже сложно и какая разница, почему бы не добавить 11? После чего всё превращается в &ldquo;ну да, у нас 234 кейсов, но рефакторить сложно, так что какая разница, что 235 добавим?&rdquo;. Чтоб избежать этой порочной практики, лучше сразу начинать писать как профессионалы.</p>
<p>Спринг позволяет сделать код, который вызывает нужный обработчик в зависимости от какой-нибудь строки несколькими методами.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"> @Autowired <span style="font-weight:bold">private</span> Map&lt;String, Handler&gt; map; <span style="font-style:italic">// key = bean id, Handler - @Bean
</span></code></pre></div><p>Тут ключ - это айди бина, имя класса - может быть полезно, но не всегда применимо. Обойти это можно добавив какой-нибудь myType() метод в общий интерфейс, и собирая словарь в конструкторе, как в следующем примере.</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="font-weight:bold">interface</span> <span style="font-weight:bold">HandlerInterface</span> { String myType(); <span style="">void</span> doWork(); }
<span style="font-style:italic">/// --
</span><span style="font-style:italic"></span>
<span style="font-weight:bold">public</span> <span style="font-weight:bold">class</span> <span style="font-weight:bold">Controller</span> {
  <span style="font-weight:bold">private</span> Map&lt;String, Handler&gt; map;

  <span style="font-weight:bold">public</span> Controller()(List&lt;HandlerInterface&gt; somethings) {
    map = somethings.stream.collect(toMap(SomethingInterface::myType), Function.identity());
  }

  <span style="font-style:italic">// ...
</span><span style="font-style:italic"></span>}
</code></pre></div><p>Ну и последний вариант - создать словарь как <code>@Bean</code>, использовать тот же метод группировки, что и в предыдущем.</p>
<p>Далее был интересный вариант того, как сделать так, что бы бины регистрировались на лету. Было показано несколько деталей, мне самым интересным показалось вот что: <code>@Autowired</code> можно вешать на любой метод, не обязательно сеттеры. Таким образом можно писать компоненты, которые при создании будут идти и регистрироваться у контроллера (например, из прошлого примера), добавив всего лишь один метод в общий интерфейс:</p>
<div class="highlight"><pre style="background-color:#fff;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">@Autowired <span style="font-weight:bold">default</span> <span style="">void</span> regMe(Controller c) {
  c.register(<span style="font-weight:bold">this</span>.getType, <span style="font-weight:bold">this</span>); 
}
</code></pre></div><p>Под конец было упомянуто, что AspectJ лучше не использовать на бизнес-логике - вас все будут ненавидеть. Но это не означает, что AspectJ бесполезен! С его помощью можно отлавливать, например, когда бросаются исключения определенного типа - и либо логгировать их особым способом, либо высылать е-мейл админу &ldquo;эта штука опять сломалась&rdquo;.</p>
<p>Презентация длилась два с половиной часа, но смотрелась на одном дыхании - настолько живо и интересно её подавали, так что кто ещё не смотрел - настоятельно рекомендую.</p>
<h1 id="и-ещё">И ещё&hellip;</h1>
<h2 id="java-licensing-tips">Java Licensing Tips</h2>
<p>От <a href="https://live.jugru.org/en/speakers/c0V7V4lnDtbF2On7Ny8WS/">Юрия</a>. Разобрал тонкости в обновлении с  JDK_8_202 на 203 - начиная с этой версии надо платить деньги в Оракл. Лучший совет здесь - советуйтесь с юристами, как именно это работает для вас, но вообще есть три варианта:</p>
<ol>
<li>Не обновляться, остаться на версии 202</li>
<li>Мигрировать на OpenJDK со свободной лицензией</li>
<li>Провести внутренний аудит, разобраться где что нужно, попробовать уменьшить количество лицензий, начать платить</li>
</ol>
<p>С точки зрения Оракл - &ldquo;использование - факт установки JDK/JRE на ваш сервер продукции&rdquo;. Да, даже если вы ею не пользуетесь. Лицензии надо покупать на физические ядра процессора.</p>
<p>Например, если у вас есть сервер с двумя процессорами Intel Xenon E3 - 2680 v4, и у каждого процессора 14 физических ядер работает и Hyper Threading - на каждом из ядер по 2 логических ядра. В этом случае нужно купить 28 (физические ядра на обоих процессорах) * 0.5 (коэффициент процессора из таблицы) = 14 лицензий. (<em>Поправил @Toofast73 в комментариях</em>)</p>
<p>Всякие облака или кубернетес - всё равно плати. Если JDK установлено для какого-то продукта Oracle (например, DB/WebLogic), то платить не надо, но и другим приложениям нельзя использовать этот JDK.</p>
<p>На обычных пользователей - платить надо по пользователю. Один пользователь сидит на 5 компьютерах - одна лицензия, пять пользователей сидят на одном компьютере - 5 лицензий.</p>
<h2 id="how-to-tell-no-to-an-architect-tips-for-sizing-a-microservice">How to tell &ldquo;no&rdquo; to an architect? Tips for sizing a microservice</h2>
<p><a href="https://twitter.com/Minimbl">Андрей</a> довольно адекватно высказался по поводу микросервисов, что процесс их проектирования не должен быть безумным процессом рисование стрелочек и коробочек, где каждая коробочка - свой микросервис. Если какие-то части продукта связаны, и одна часть не может быть изменена без другой - надо ли разбивать их на два микросервиса, когда можно оставить всё в одном? В конце концов, разбить один сервис в несколько вы всегда успеете.</p>
<h2 id="will-robots-replace-programmers">Will robots replace programmers?</h2>
<p>Довольно интересный рассказ <a href="https://twitter.com/tagir_valeev">Тагира</a>, где он анализирует тренды развития инструментов программирования. На мой взгляд, доклад скорее оптимистичный - да, тупой рутинной работы становится меньше, но и робот никогда не сможет точно отловить все нюансы. Скорее всего будущее - в тандеме между разработчиком и вспомогательными инструментами, часть из которых будет разработана с использованием техник машинного обучения.</p>
<h1 id="заключение">Заключение</h1>
<p>Теперь, спустя три, кажется, недели могу сказать, что конференция была просто отличной. Для себя я узнал много нового, добавил всех докладчиков, кого нашел, в твиттере, успел даже попробовать кое-что у себя на проектах. Жаль, не было времени походить по залам в игровом виде, но думаю, это уже на другой раз можно будет отложить.</p>
<p>Этот конспект я делал на английском, слушая оригинальные трансляции. Не был уверен в том, нужны ли они кому-то, но оказалось, что интерес был - поэтому перевёл обратно на русский и получил эту статью. Сам я синьор не настоящий, опыта маловато, и я допускаю, что допустил неточности в некоторых темах. Тем более при переводе терминов на русский - сам я всю жизнь работаю на английском, переводить не привык. Тем не менее я очень надеюсь, что я не исказил смысла оригинальных презентаций, и не внёс никаких ошибок от себя. Но если что - пишите, всё исправлю!</p>

      </div>

      <footer>
        


        
      </footer>
    </article>

    
  </section>

      </div>

      <footer class="footer">
  <section class="container">
    
      <p>Simplifying stuff for business needs</p>
    
     © 2021
    
       · 
      Powered by <a href="https://gohugo.io/">Hugo</a> & <a href="https://github.com/luizdepra/hugo-coder/">Coder</a>.
    
    
  </section>
</footer>

    </main>

    

  </body>

</html>
